### 事务


[参考:MySQL-事务隔离级别设置](http://www.cnblogs.com/JohnABC/p/3521061.html)

#### 事务（Transaction）及其ACID属性

```  
原性性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

```


#### 事务的并发问题


##### 脏读

**一个事务读到另一个事务，尚未提交的修改，就是脏读**，这里所谓的修改，除了Update操作,不要忘了,还包括Insert和Delete操作。脏读的后果：如果后一个事务回滚，那么它所做的修改，统统都会被撤销。前一个事务读到的数据，就是垃圾数据。

##### 不可重复读

**在同一个事务中，再次读取数据时【就是你的select操作】，所读取的数据，和第1次读取的数据，不一样了。就是不可重复读**
你的查询结果，将是不确定的。一个不确定的结果，你能容忍吗？

##### 幻读

事务1读取指定的where子句所返回的一些行。然后，事务2插入一个新行，这个新行也满足事务1使用的查询where子句。然后事务1再次使用相同的查询读取行，但是现在它看到了事务2刚插入的行。这个行被称为幻象，因为对事务1来说，这一行的出现是不可思议的


##### 更新丢失

当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题

##### 不可重复读与幻读的区别

```  
脏读的重点是读另一个事务未提交的数据(假若那个事务RollBack, 则这数据就是无效的):某个事务已更新一份数据, 另一个事务在此时读取了同一份数据, 由于某些原因, 前一个RollBack了操作, 则后一个事务所读取的数据就会是不正确的

不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了

幻读的重点在于新增或者删除: 同样的条件, 第1次和第2次读出来的记录数不一样

当然, 从总的结果来看, 似乎两者都表现为两次读取的结果不一致, 但如果你从控制的角度来看, 两者的区别就比较大, 对于不可重复读, 只需要锁住满足条件的记录, 对于幻读, 要锁住满足条件及其相近的记录

```

#### 事务的隔离级别

#### 查看隔离级别

```  
select @@tx_isolation;  #查看当前会话隔离级别

select @@global.tx_isolation; #查看系统当前隔离级别

```

#### 设置隔离级别

##### 第一种，通过set 语法动态设置

```  

set tx_isolation='read-committed';  #设置当前会话隔离级别

set global transaction isolation level read committed; #设置系统当前隔离级别

```

##### 第二种，通过配置文件my.cnf


```   
[mysqld]transaction-isolation= REPEATABLE-READ

```


##### read uncommitted（读取未提交内容）

```   
在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）

别人随便说说，没实际做
```

##### read committed（读取提交内容）

```  
一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

```

##### repeatable read（可重读）

```  
这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题

```

##### serializable（可串行化）

```  
这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争

```

##### 可产生的问题

|隔离级别 | 脏读 | 不可重复读 | 幻读|
| ------ | ------ | ------ | ------|
|读未提交|是|是|是|
|读已提交|否|是|是|
|可重复读|否|否|是|
|可串行化|否|否|否|

快照读(Snapshot Read)，这种不加锁的读，是InnoDB高并发的核心原因之一

### InnoDB如何实现事务的隔离级别

使用不同的锁策略(Locking Strategy)来实现不同的隔离级别

1. RU: select语句不加锁
2. Serializable: 所有select语句都会被隐式的转化为select ... in share mode
3. RR: 普通select快照读，锁select /update /delete 根据查询条件情况，会选择记录锁，或者间隙锁/临键锁，以防止读取到幻影记录
4. RC: 普通select快照读，锁select /update /delete 会使用记录锁，可能出现不可重复读；
 










