## Redis

#### Redis的编程模型

单进程单线程

##### 为什么快

- 完全基于内存
- 结构简单
- 多路I/O复用模型

##### 好处

- 代码清晰,简单
- 无加锁消耗,和死锁问题
- 无进程线程切换CPU消耗

##### 坏处

- 无法发挥多核性能,可通过多部署实例

#### 数据类型及应用场景

- string（字符串）: 基本的数据存储单元，可以存储字符串、整数或者浮点数。一个键最大能存储 512MB。
- hash（哈希）:一个键值对集合，可以存储多个字段。每个哈希最多可以存储 2^32 - 1 个键值对。模拟session的效果。
- list（列表）:一个简单的列表，可以存储一系列的字符串元素。列表最多可以存储 2^32 - 1 个元素。
- set（集合）:一个无序集合，可以存储不重复的字符串元素。哈希表实现的。
- zset(sorted set：有序集合): 类似于集合，但是每个元素都有一个分数（score）与之关联。底层采用压缩表ziplist（元素少于128）或跳表skiplist和哈希表的数据结构实现。
- 位图（Bitmaps）：基于字符串类型，可以对每个位进行操作。
- 超日志（HyperLogLogs）：用于基数统计，可以估算集合中的唯一元素数量。
- 地理空间（Geospatial）：用于存储地理位置信息。
- 发布/订阅（Pub/Sub）：一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息。
- 流（Streams）：用于消息队列和日志存储，支持消息的持久化和时间排序。
- 模块（Modules）：Redis 支持动态加载模块，可以扩展 Redis 的功能。


#### 过期策略以及内存淘汰机制

定期删除+惰性删除策略

定期删除: 100ms随机抽取key检查
惰性删除: 获取某个key,检查是否过期

##### 内存淘汰策略(内存不足)
- noeviction 报错
- allkeys-lru 移除最近最少使用 **推荐**
- allkeys-random 随机删除

#### 部署

1. Master-Slave模式,主宕机,从变为主,哨兵模式
2. 集群分片(哈希Slot)

##### 哨兵模式的缺点
1. 哨兵宕机,故障转移失效
2. 应用端需要先访问哨兵才能访问主库

##### 主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：

- 海量数据存储问题
- 高并发写的问题



#### 持久化
1. RDB 数据快照
2. AOF 命令顺序执行

##### 主从同步策略
主从刚刚连接的时候，进行全量同步(RDB)；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步


#### 其他开源软件模型

- Nginx 多进程单线程
- Memcached 单进程多线程模型

#### String和Hash(ziplist)，什么情况下用Hash更省内存。

- 哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；
- 哈希对象保存的键值对数量小于 512 个；

