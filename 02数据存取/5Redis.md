## Redis

#### Redis的编程模型

单进程单线程

##### 为什么快

- 完全基于内存
- 结构简单
- 多路I/O复用模型

##### 好处

- 代码清晰,简单
- 无加锁消耗,和死锁问题
- 无进程线程切换CPU消耗

##### 坏处

- 无法发挥多核性能,可通过多部署实例

#### 数据类型及应用场景

1. String 一般做一些复杂的计数功能的缓存
2. Hash 结构化的对象 模拟session的效果
3. List 字符串列表，按照插入顺序排序  简单的消息队列的功能
4. Set 通过哈希表实现的 去重,交集/并集/差集
5. Sorted Set 有序集合 排行榜 TOPN


#### 过期策略以及内存淘汰机制

定期删除+惰性删除策略

定期删除: 100ms随机抽取key检查
惰性删除: 获取某个key,检查是否过期

##### 内存淘汰策略(内存不足)
- noeviction 报错
- allkeys-lru 移除最近最少使用 **推荐**
- allkeys-random 随机删除

#### 部署

1. Master-Slave模式,主宕机,从变为主,哨兵模式
2. 集群分片(哈希Slot)

##### 哨兵模式的缺点
1. 哨兵宕机,故障转移失效
2. 应用端需要先访问哨兵才能访问主库


#### 持久化
1. RDB 数据快照
2. AOF 命令顺序执行

##### 主从同步策略
主从刚刚连接的时候，进行全量同步(RDB)；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步


#### 其他开源软件模型

- Nginx 多进程单线程
- Memcached 单进程多线程模型

#### String和Hash(ziplist)，什么情况下用Hash更省内存。

- 哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；
- 哈希对象保存的键值对数量小于 512 个；

