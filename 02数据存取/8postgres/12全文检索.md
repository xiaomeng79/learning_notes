## 全文检索


#### 中文全文检索

[docker_pg_jieba](https://github.com/chen-xin/docker_pg_jieba)

1. 安装中文分词插件(选择一个)
    -  [scws简单中文分词系统](https://github.com/hightman/scws) 中文分词库
    -  [zhparser](https://github.com/amutu/zhparser)
    -  [pg_jieba](https://github.com/jaiminpan/pg_jieba)

2. 开启拓展(pg_jieba为例)
```sql
test=# create extension pg_jieba;
CREATE EXTENSION
test=# \dx
                        List of installed extensions
   Name   | Version |   Schema   |               Description                
----------+---------+------------+------------------------------------------
 pg_jieba | 1.1.0   | public     | a parser for full-text search of Chinese
 plpgsql  | 1.0     | pg_catalog | PL/pgSQL procedural language

```
3. 创建数据库结构
```sql
-- 创建数据库,支持中文字符
-- create database test with template template0 lc_collate "zh_CN.UTF8" lc_ctype "zh_CN.UTF8" encoding 'UTF8';

create table p(                                                                         
name varchar(20) not null default '', --默认文本
name_tsv tsvector); --分词文本

-- 查看分词名称

test=# \dF
                  List of text search configurations
   Schema   |    Name    |                Description                 
------------+------------+--------------------------------------------
 pg_catalog | english    | configuration for english language
 public     | jiebacfg   | Mix segmentation configuration for jieba
 public     | jiebaqry   | Query segmentation configuration for jieba

-- 查看默认的全文检索分词配置
test=# SHOW default_text_search_config;
 default_text_search_config 
----------------------------
 pg_catalog.english
(1 row)


-- 创建触发器
create trigger nametsupdate before insert or update on p for each row execute procedure 
tsvector_update_trigger(name_tsv,'public.jiebacfg',name);

-- 如果有旧数据,更新
update p set name_tsv = to_tsvector('jiebacfg',coalesce(name,''));

```

4. 创建gin或gist索引
```sql
create index idx_name on p using gin(name_tsv);
create index idx_name on p using gist(name_tsv);

```

#### 模糊查询

##### 支持的模式匹配
- Like
- POSIX正则表达式
- SIMILAR TO正则表达式

##### 模糊查询使用索引(pg_trgm)

**pg_trgm前后模糊字符个数要求:**

有前缀的模糊查询，例如a%，至少需要提供1个字符。( 搜索的是token=' a' )
有后缀的模糊查询，例如%ab，至少需要提供2个字符。( 搜索的是token='ab ' )
前后模糊查询，例如%abcd%，至少需要提供3个字符。( 这个使用数组搜索，搜索的是token(s) 包含 {" a"," ab",abc,bcd,"cd "} )
因为pg_trgm生成的TOKEN是三个字符，只有在以上三个条件下，才能匹配到对应的TOKEN

```sql
test=# select show_trgm('abc');
        show_trgm        
-------------------------
 {"  a"," ab",abc,"bc "}
(1 row)

```

##### 小于3个输入字符的模糊查询的优化

1. 分割字符函数
```sql
-- 分割字符函数
create or replace function split001(text) returns text[] as 
$$
     
declare      
 res text[];      
begin      
 select regexp_split_to_array($1,'') into res;      
 for i in 1..length($1)-1 loop      
   res := array_append(res, substring($1,i,2));      
 end loop;      
 return res;      
end;      

$$
language plpgsql strict immutable;

```
2. 表格式
```sql
-- 创建表结构

-- 插入数据
insert into t_trgm select gen_hanzi(5) from generate_series(1,1000000);

```
3. 生成表达式索引
```sql
create index idx_t_2 on t_trgm using gin (split001(name));
```

4. 使用索引
```sql
test=# explain (analyze,buffers,costs,timing) select * from t_trgm where split001(name) @>split001('孟');
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on t_trgm  (cost=74.63..7588.84 rows=5500 width=15) (actual time=0.060..0.264 rows=276 loops=1)
   Recheck Cond: (split001(name) @> '{孟}'::text[])
   Heap Blocks: exact=267
   Buffers: shared hit=271
   ->  Bitmap Index Scan on idx_t_2  (cost=0.00..73.25 rows=5500 width=0) (actual time=0.035..0.035 rows=276 loops=1)
         Index Cond: (split001(name) @> '{孟}'::text[])
         Buffers: shared hit=4
 Planning Time: 0.073 ms
 Execution Time: 0.284 ms
(9 rows)

```



#### 测试数据

生成汉字
```sql
create or replace function gen_hanzi(int) returns text as 
$$
                 
declare        
 res text;        
begin        
 if $1 >=1 then        
   select string_agg(chr(19968+(random()*20901)::int), '') into res from generate_series(1,$1);        
   return res;        
 end if;        
 return null;        
end;        

$$
language plpgsql strict;  
```

#### 注意问题

1. pg_jieba每次首次加载数据慢
```bash
pg_jieba.so没有放在shared_preload_libraries或session_preload_libraries中，那么每个会话启动时，都需要load pg_jieba.so，从而导致了第一次查询速度非常慢。
```
解决:
```bash
vi postgresql.conf  
   
shared_preload_libraries = 'pg_jieba.so'  
or  
session_preload_libraries = 'pg_jieba.so' 
#重启数据库
pg_ctl restart -m fast  
 
```

