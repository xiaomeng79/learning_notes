## 限流

[go限流](https://github.com/juju/ratelimit)

[go uber](https://github.com/uber-go/ratelimit)

### 为什么要限流?

对外web api服务，由于用户增长过快,热点事件,秒杀,爬虫,刷单等流量猛增拖垮机器
对内的rpc服务，由于调用方流量猛增，导致被调用方挂掉

### 限流算法


#### 计数器(固定时间窗口限流算法)

限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数

#### 漏桶算法

算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变，桶满了，请求丢弃

弊端：无法应对短时间的突发流量

#### 令牌桶算法

在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择等待可用的令牌、或者直接拒绝。


### 集群限流

每次有相关操作的时候，就向redis服务器发送一个incr命令，比如需要限制某个用户访问/index接口的次数，只需要拼接用户id和接口名生成redis的key，每次该用户访问此接口时，只需要对这个key执行incr命令，在这个key带上过期时间，就可以实现指定时间的访问频率。





