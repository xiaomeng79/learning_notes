## 消息队列对比

|    |Kafka   |RabbitMq    |ActiveMq   |Redis   |Nsq  |ActiveMq|
|---|---|---|---|---|---|---|
|单机吞吐量|十万级|万级|万级|十万级(小数据)|||
|部署|中|底|底|底|底||
|消息堆积|支持|支持(有阈值)|支持(有阈值)|支持(有阈值)|||
|持久化|支持|支持||支持||支持|
|多语言|支持|支持|支持|支持|支持||
|消息延迟|不支持|支持|支持|支持|||
|消费模式|拉|推+拉|推+拉|拉|||
|常用场景|日志，大数据|金融支付|降低耦合|共享cache，session|||
|事务||||||XA事务|
|动态扩容|支持zk|不支持|不支持||||

### **RabbitMQ、Kafka、RocketMQ 的区别是什么？**
| 对比项       | RabbitMQ       | Kafka        | RocketMQ     |
|-------------|---------------|-------------|-------------|
| **数据存储** | 基于内存+磁盘  | 仅基于磁盘存储 | 基于磁盘存储 |
| **吞吐量**   | 低（万级）    | 高（百万级） | 中等（十万级） |
| **消息顺序** | 队列保证顺序  | 分区保证局部顺序 | 队列保证顺序 |
| **消费模式** | **Push**      | **Pull**    | **Pull** |
| **事务支持** | 支持事务       | 不支持事务  | 支持事务 |
| **典型应用** | 短信、邮件    | 日志收集、数据分析 | 订单、支付 |

### **如何保证 MQ 消息不丢失？**
**回答：**
1. **生产端**
   - **消息持久化**（RabbitMQ 开启 `persistent=true`）
   - **事务模式**（RabbitMQ 开启事务，但降低吞吐量）
   - **发送确认机制（Confirm）**
2. **消息队列**
   - **持久化存储**（Kafka 默认写入磁盘日志）
   - **多副本机制**（Kafka `replication` 参数）
3. **消费端**
   - **ACK 机制**（RabbitMQ 需要 `ack=true`）
   - **幂等性处理**（防止重复消费）



### **如何保证 MQ 消息顺序？**
**回答：**
1. **单个分区（单个队列）**
   - 在 **Kafka** 中，同一类消息写入同一个分区
   - 在 **RabbitMQ** 中，只让一个消费者消费该队列
2. **有序消费**
   - **Kafka**：消费者按 **同一分区** 读取消息
   - **RabbitMQ**：使用 **x-delayed-message** 插件
3. **全局顺序**
   - 只能保证某个 **key** 级别的顺序，全局顺序 MQ 无法保证

### **Q7: 如何扩展 RabbitMQ？支持动态扩容吗？**
**回答：**
1. **手动添加节点**
2. **Kubernetes 动态扩容**
3. **分片机制**
   - 采用 **多个队列**，不同队列存放不同的消息类型
