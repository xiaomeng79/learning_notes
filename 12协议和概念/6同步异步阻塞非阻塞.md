### I/O操作
1. 等待数据准备好(读到内核缓存)
2. 将数据从内核读到用户空间(进程空间)

### 阻塞与非阻塞
**指应用程序**
阻塞:应用程序执行i/o操作后,没获得响应,就一直等待
非阻塞:应用程序执行i/o操作后,不阻塞当前的线程,可执行其他任务

### 同步与异步
**指i/o执行者(内核系统)**
同步:收到i/o请求后,不立即响应应用程序,等处理完成,才会告诉结果
异步:收到i/o请求后,告诉应用程序收到请求了,然后异步处理,等完成后,通过事件通知的方式,告诉应用程序结果

### 单服务器高性能模式

- PPC(Process Per Connection) 多进程模式 每次有新的连接就新建一个进程去专门处理
- TPC(Thread Per Connection) 多线程模式
- Reactor模式 非阻塞同步  中文叫"反应堆" 事件驱动的，有一个或多个并发输入源,核心组成部分包括 Reactor 和处理资源池（进程池或线程...
- Proactor模式 非阻塞异步
  

### select/poll/epoll

[详细介绍](https://www.cnblogs.com/creazylinux/p/7364685.html)
[io多路复用](https://blog.csdn.net/snoweaglelord/article/details/99681179)

select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作

**但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。**

#### select缺点

- select支持的文件描述符数量太小了，使用数组保存,默认是1024
- select每次调用select都需要重新想内核传递监听的描述符，浪费了一些开销，这个开销在fd很多时会很大
- 同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大

#### poll

和select差不多,只是对监听描述符集的描述有差异

#### epoll
- 使用红黑树保存fd
- 用户空间通过epoll_ctl函数讲要监听的的各个描述符的事件传递给内核空间
- epoll_ctl会为每个描述符指定回调函数,当有事件发生,回调函数将文件描述符添加到一个就绪队列中
- epoll_wait用于阻塞监听查看队列是否为空,不为空有事件发生

#### 总结

- select/poll 轮询全部的fd,查看是否就绪,epoll只判断wait中就绪的fd
- select/poll 每次轮询都要拷贝,epoll只拷贝一次
- epoll文件描述符最大65535



