# ETH

## 合约执行流程
- 当一个合约编写完成并成功编译后，我们就可以把它部署到以太坊上。合约部署后将自动获得一个地址，通过该地址即可访问合约。
- 把`contract`看作一个类，部署就相当于一个实例化。
- 构造函数在部署合约时就会立刻执行，且仅执行一次。合约部署后就无法调用构造函数。
- 任何外部账户都可以发起对合约的函数调用。如果调用只读方法，因为不改变合约状态，所以任何时刻都可以调用，且不需要签名，也不需要消耗Gas。但如果调用写入方法，就需要签名提交一个交易，并消耗一定的Gas。

## 验证
- 最常用的require()可以断言一个条件，如果断言失败，将抛出错误并中断执行。
- 以太坊合约具备类似数据库事务的特点，如果中途执行失败，则整个合约的状态保持不变。
- 合约如果执行失败，其状态不会发生任何变化，也不会有任何事件发生，仅仅是调用方白白消耗了一定的Gas。
- 检查都必须在合约的函数内部完成。

## 部署
- 测试地址:faucet.egorfine.com或faucet.dimensions.network获取一些测试网的Ether。

## 调用合约
- 页面的JavaScript代码无法直接访问以太坊网络的P2P节点，只能间接通过MetaMask钱包访问；
- 钱包之所以能访问以太坊网络的节点，是因为它们内置了某些公共节点的域名信息；
- 如果用户的浏览器没有安装MetaMask钱包，则页面无法通过钱包读取合约或写入合约。

## Dapp架构如下：

 ┌───────┐     ┌─────────┐     ┌───────┐
 │Wallet │◀────│Web Page │────▶│Server │
 └───────┘     └─────────┘     └───────┘
     │                             │
 read│write                        │read
     │                             │
┌ ─ ─│─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ┐
     ▼                             ▼
│ ┌─────┐        ┌─────┐        ┌─────┐ │
  │Node │────────│Node │────────│Node │
│ └─────┘        └─────┘        └─────┘ │
     │              │              │
│    │    ┌─────┐   │   ┌─────┐    │    │
     └────│Node │───┴───│Node │────┘
│         └─────┘       └─────┘         │
           Ethereum Blockchain
└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
为Dapp搭建后端服务器时要严格遵循以下规范：
- 后端服务器只读取合约，不存储任何私钥，因此无法写入合约，保证了安全性；
- 后端服务器要读取合约，就必须连接到P2P节点，要么选择公共的节点服务（例如Infura），要么自己搭建一个以太坊节点（维护的工作量较大）；
- 后端服务器应该通过合约产生的日志（即合约运行时触发的event）监听合约的状态变化，而不是定期扫描。监听日志需要通过P2P节点创建Filter并获取Filter返回的日志；
- 后端服务器应该将从日志获取的数据做聚合、缓存，以便前端页面能快速展示相关数据。
因此，设计Dapp时，既要考虑将关键业务逻辑写入合约，又要考虑日志输出有足够的信息让后端服务器能聚合历史数据。前端、后端和合约三方开发必须紧密配合。

## 托管后端服务
- [graph](https://thegraph.com/zh/)
The Graph可以让我们部署一个Graph查询服务，如何定义表结构以及如何更新则由我们提供一个预编译的WASM。整个配置、WASM代码以及查询服务都托管在The Graph中，无需自己搭建服务器，非常方便。

因此，使用Graph的一个完整的DApp架构如下：

                ┌───────┐
    ┌───────────│ DApp  │───────────┐
    │           └───────┘           │
    │ read/write              query │
    │ contract                 data │
    ▼                               ▼
┌───────┐                       ┌───────┐
│Wallet │                       │ Graph │
└───────┘                       └───────┘
    │                               ▲
    │ sign                    index │
    │ broadcast                data │
    │                               │
    │  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─  │
    │    ┌────┐ ┌────┐     ┌────┐ │ │
    └──┼▶│Node│ │Node│ ... │Node│───┘
         └────┘ └────┘     └────┘ │
       │         Ethereum
        ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘

## 安全性
- 加减导致的溢出
  - 从Solidity 0.8版本开始，编译器默认就会检查运算溢出，因此，不要使用早期的Solidity编译即可避免溢出问题。
- 条件不满足必须抛出异常回滚交易
- 重入攻击
  - 防止重入攻击的方法是一定要在校验通过后立刻更新数据，不要在校验-更新中插入任何可能执行外部代码的逻辑。
  - 
```solidity
  // 先回调再更新的方式会导致重入攻击，即如果callback()调用了外部合约，外部合约回调transfer()，会导致重复转账
  function transfer(address recipient, uint256 amount) public returns (bool) {
    require(recipient != address(0), "ERC20: transfer to the zero address");
    uint256 senderBalance = balanceOf[msg.sender];
    require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
    // 此处调用另一个回调:
    callback(msg.sender);
    // 更新转账后的额度:
    balanceOf[msg.sender] = senderBalance - amount;
    balanceOf[recipient] += amount;
    emit Transfer(sender, recipient, amount);
    return true;
    }
```

## EVM
是以太坊网络中运行智能合约的全局分布式计算机，负责执行合约字节码并更新区块链状态。
### 核心特点包括:
- ​确定性​​：相同输入下执行结果唯一
- ​隔离性​​：运行在沙盒环境中，无法直接访问外部系统。
- ​燃料（Gas）驱动​​：每步操作消耗 Gas，防止资源滥用。

### 核心组件

| **组件**             | **功能**                                                           |
| -------------------- | ------------------------------------------------------------------ |
| **堆栈（Stack）**    | 保存临时数据（深度为 1024，每个槽位 256 位），用于算术和逻辑运算。 |
| **内存（Memory）**   | 临时数据存储（按字节寻址，读写成本低于存储）。                     |
| **存储（Storage）**  | 永久性键值存储（每个合约独立，读写成本高）。                       |
| **程序计数器（PC）** | 指向当前执行的字节码位置。                                         |
| **Gas 计数器**       | 跟踪剩余 Gas，耗尽则终止执行并回滚状态。                           |

---

### 数据模型
- **256 位字长**：所有操作基于 256 位数据（兼容以太坊的 32 字节地址和哈希）。  
- **大端序（Big-Endian）**：数据高位存储在低地址。

### EVM 执行流程
- 交易触发
  - **用户发起交易**：调用合约函数或转账 ETH。  
  - **交易包含**：目标地址、输入数据、Gas 限制、Gas 价格等。
- 字节码加载
  - **合约部署**：合约的 Solidity/Vyper 代码编译为 EVM 字节码（如 `606060...`）。  
  - **执行上下文**：创建执行环境（包括账户状态、Gas 余额等）。
- 指令执行
  - **操作码（Opcode）**：EVM 的底层指令集（如 `PUSH1`, `ADD`, `SSTORE`）。  
  - **逐条解析**：从字节码中读取操作码，更新堆栈、内存或存储。  
- Gas 消耗
  - ​每步操作消耗 Gas​​：例如 ADD 消耗 3 Gas，SSTORE 首次写入消耗 20,000 Gas。
- 状态更新


